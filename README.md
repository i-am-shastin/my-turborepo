# My Turborepo

Реализация невероятно сырая и не учитывает различные аспекты и нюансы аутентификации. Для быстрого теста нужно выполнить команду:
```sh
docker-compose up
```
Это поднимет инстанс Postgres, выполнит миграцию БД, запустит [Prisma Studio](http://localhost:5555) (можно будет вручную отозвать refresh_token), [бэкенд](http://localhost:30000/api) и [фронтенд](http://localhost:3000).

## Что внутри?

- `apps/api`: Бэкенд с NestJS + Swagger + Zod + Postgres + Prisma
- `apps/web`: Фронт на Next.js + Shadcn
- `@repo/database`: Отдельный пакет под Prisma, который собирает клиента для `apps/api`
- `@repo/crypto`: Обёртка над bcrypt (с фиксированным количеством раундов хэширования) для использования в `apps/api` и в `@repo/database` (в последнем необходима при сидировании БД)

## Билдим локально:

Сперва нужно передать переменные окружения приложениям:

`.env` для `apps/api`:

```sh
JWT_ACCESS_SECRET='some_secret'
JWT_ACCESS_EXPIRE_SECONDS=900
JWT_REFRESH_SECRET='another_secret'
JWT_REFRESH_EXPIRE_SECONDS=604800
```

`.env` для `apps/web`:

```sh
NEXT_PUBLIC_API_URL='http://localhost:30000'
```

`.env` для `packages/database`:

```sh
DATABASE_URL="postgresql://$MY_DB_USER:$MY_DB_PASSWORD@localhost:5432/$MY_DB_NAME"
```

После создания переменных окружения можно поднимать приложения:

```sh
npm install
docker-compose up postgres
npx turbo db:migrate
npx turbo dev
```

## Rambles:
У меня не задалось с самого начала - изначально я начал собирать репозиторий с двумя приложухами, заинсталлил Prisma в NestJS, а потом увидел, что обязательно нужен ещё и пакет :) Потом сходу не получилось нормально импортировать содержимое пакета database в бэк - не сразу понял, что NestJS требует уже сбилженные пакеты.

Когда поднял бэк и начал конфигурировать - оказалось, что встроенный механизм аутентификации зависит от @passport, с которым я до этого не работал. Потом выяснилось, что из коробки там нет рефреш токенов (или я упустил этот момент в документации). С реализацией HttpOnly кукис тоже возникли проблемы - парсить токен из куков/писать его в `Response` нужно вручную (или, опять же, я не знаю какую-то магическую функцию/библиотечку).

Ну и с клиентской частью тоже печально - из-за HttpOnly кукисов пришлось ковыряться с документацией Nextjs, в итоге сделал _далеко_ не так, как хотелось бы и __совсем__ не так, как нужно :)
Сейчас middleware предполагает, что при наличии access_token всё ок - либо рефрешит его, если присутствует refresh_token. Но при этом access_token совершенно никак не валидируется. В SvelteKit я бы сгруппировал маршруты /profile и /users и вызывал бы /api/me, передавая результат успешного вызова в layout data - в этом случае валидация access_token происходила бы автоматически для всех защищённых маршрутов, а страница /profile использовала бы эти данные при SSR.

В-общем, я пытался как мог, но имхо подобные шаблоны приложений создаются совсем не за пару дней, если реализовывать всё по уму. Я полноценную систему с RBAC и токенами (с учётом того, что юзал готовые библиотечки) создавал почти что месяц, пока не довёл большинство пользовательских сценариев до ума.
